
\documentclass{subfiles}

\begin{document}
In 1984, Crow proposed an image representation where each pixel value is replaced by the sum of all the pixels that belong to the rectangle defined by the lower left corner of the image and the pixel of our interest (Crow, 1984).  Even though more storage space is required to save the image, due to the larger numbers, the sum of every rectangle in the image can be calculated in constant time, once the table is constructed. The integral image can also be constructed in linear time O(n), where n is the number of pixels in the image. One iteration through the entire image is enough to replace the pixel values of the image. \newline

image
\newline




\section{Optimising Surface Reconstruction}\label{sec:OptimisationSurfaceReconstruction}
The original Marching Cubes algorithm uses a scan line approach and processes all the cubes sequentially. The scan line approach sometimes implies looping through large amounts of empty cubes. To optimise the process, in this research, it is proposed an algorithm that repeatedly divides the volume and utilities Integral Volumes to discard empty volumes during the polygonisation. Using this optimisation algorithm it was achieved an up to 51% speed-up. 
This optimisation algorithm is explained in the following sections, which are structured as follow:
-	Background information, including previous related work. 
-	How integral images are extended into 3D. 
-	The proposed algorithm of using Integral Volumes to speed up the process of polygonising an implicit object using the Marching Cubes algorithm
-	Implementation details that contribute to the efficiency and speed up of the algorithm
-	Results
\subsection{Background}\label{Vis_Background}
Much research has been done so far on optimising and improving the polygonisation of implicit surfaces. But most research is based on closed and manifold object. A polygon mesh is closed when it has no holes and it is manifold when it can be unfolded into a 2D continues surface. In order to guarantee consistent topology, an optimised approach with an enhanced look up table was proposed by Lewiner et al in 2003. \newline\newline
Further surface-tracking was discussed in both papers of (Rodrigues de Araujo and Pires Jorge, 2005) (Hartmann, 1998). Starting from a seed point, the surface is expanded according to the local curvature of the implicit object. Self-intersections and collisions are avoided using heuristic edge length. This method is considered to be faster and more efficient, in comparison with the Marching Cubes algorithm. Because, by tracking the surface, huge empty spaces are not searched and it is also possible to create smaller triangles on places with high gradient changes and bigger triangles on surfaces with low variance. Nevertheless, surface-tracking Algorithms cannot be applied in our case though, because the output of on my program is a non-manifold objects. The 3D Volume generated from FW LiDAR data is not consistent, since small footprint Leica FW systems cannot guarantee that the last return is from the ground. For that reason, it is possible that some trees may be separated from the ground. Surface-tracking algorithms converge once the object is closed. Therefore, there is a possibility that they may converge after polygonising a single tree if the seed point lies on a tree that is separated from the ground. \newline\newline
In 1992, Hansen and Hinker proposed parallelising the polygonisation process of BlobTree trees on Single Instruction, Multiple Data (SIMD) machines. BlobTree trees represent implicit objects as a combination of primitives and operations likes union and blends (Galbraith, MacMurchy, and Wyvill, 2004). While the depth of the tree increases, the time required to get the value that defines whether a point is inside or outside the object increases as well. On SIMD machines greater speed up is achieved at longer instruction due to the less communication cost. Therefore parallelising the process of BlobTree trees with long depth is beneficial, but in our case the value returned for a given point is calculated in constant time. Further, according to the C++ Coding Standards by Sutter and Alexandrescu, when optimisation is required is better to seek an algorithmic approach first because it is simpler to maintain and the possibility of being bug free is higher (Sutter and Alexandrescu, 2004). \newline\newline
OpenVDB library manages volumetric data with octrees. My program uses 1D arrays allowing constant time access of voxel values and by importing OpenVDB library, its speed was significantly decreased; while the number of voxels is increasing the time required to get the value of a voxel is also increasing. Further according to the documentation, the VolumeToMesh class “meshes any scalar grid that has a continuous isosurface”, while the surface of the FW LiDAR volumes is not continuous; there are triangles that represent leafs inside the trees and some of the trees may be disconnected from the ground because the last return do not always reach the earth  (OpenVDB 2.3.0). \newline\newline
In this report, it is introduced a new method of optimising the marching cubes algorithm. This method utilises Integral Volumes (an extension of Integral Images) to discard chunks of empty cubes during polygonisation. Its effectiveness stands at the ability of integral volumes to find the sum of any sub-volume into constant time and it is important because it works effectively non-manifold or non-closed objects. \newline\newline

\section {? Summary}

Then an algebraic representation of that volume is defined by the function $f(X)$ and the iso-surface value $\alpha$. The function $f(X)$ takes as input a point $X$ and returns the associated intensity of the voxel that $X$ lies inside. If the returned intensity is greater than the value $\alpha$ then $X$ lies inside the algebraic object, if it is is equal to $\alpha$ then it is on the boundary otherwise it lies outside.
\end{document}