\documentclass{subfiles}

\begin{document}

\par Non calibrated intensities do not significantly affect the creation of polygon meshes, because during polygonisation, the system treats the intensities as Booleans; is that voxel empty or not? Nevertheless, the noise level could be set lower if the intensities were calibrated and more details would be preserved on the polygon meshes. For that reason, calibrating the intensities of the return is a task needing to be performed in order to enable the use of intensities in future classifications. 

	
\par Even though numerical implicitization is beneficial in reducing storage memory and for various resolution renderings of the same object, visualising numerical/algebraic objects is not straight forward, since they contain no discrete values. More information about visualisations are given at Section \ref{Visualisations}. 

\par A big part of this thesis is the way of handing data and how algorithmic approaches can speed up accessing of FW LiDAR data while keeping memory allocation low. The next sections explains the data structures implemented and the new ones proposed during this studies. The functionalities are explained here while their performance is discussed at section \ref{Visualisations}. 

\par The names of the data structures are the given below. Some names are from standard data structures and the new ones proposed have 
\begin{enumerate}[noitemsep]
	\item 1D array
	\item 1D hashed array
	\item Octree
	\item Integral Volumes
	\item Integral Tree
	\item Hashed OCtree
	\item Series of Hashed Octrees
\end{enumerate} 
	
	
Even though numerical implicitisation is beneficial in reducing storage memory and for various resolution renderings of the same object, visualising numerical/algebraic objects is not straight forward, since they contain no discrete values. This problem can either be address either by ray-tracing or polygonisation. In 1983, Hanraham suggested a ray-tracing approach, where an equation is derived from the ray and surface intersection \cite{Hanrahan1983}.  The Marching Cubes algorithm was later introduced for polygonising implicit objects. The algorithm first divides the space into cube and then creates consistent triangle using look up table \cite{Lorensen1987}. \newline\newline

The Marching cubes algorithm constructs surfaces from implicit objects using a search table. Let’s assume that f(X) defines an implicit object. At first the space is divided into cubes, named voxels. Each voxel is defined by eight corner points, which lie either inside or outside the object. By enumerating all the possible cases and linearly interpolating the intersections along the edges, the surface of the implicit object is constructed \cite{Lorensen1987}.\newline\newline

According to Lorensen and Cline, the normal of each vertex is calculated by measuring the gradient change. But in our case, due to the high gradient changes inside the volume, calculating the normal in that way leads to a non-smooth visualisation. For that reason, in this research the normal of each vertex is equal to the average normal of its adjacent triangles. \newline\newline

Further the sampling of the Marching cubes is independent from the sampling of the 3D density volume. Therefore consistency between the two is required and more information about that is given at the results section 4.5.5. 

\subsection{Optimising Marching Cubes}
The original Marching Cubes algorithm uses a scan line approach and processes all the cubes sequentially. The scan line approach sometimes implies looping through large amounts of empty cubes. To optimise the process, in this research, it is proposed an algorithm that repeatedly divides the volume and utilities Integral Volumes to discard empty volumes during the polygonisation. Using this optimisation algorithm it was achieved an up to 51% speed-up. 
This optimisation algorithm is explained in the following sections, which are structured as follow:
-	Background information, including previous related work. 
-	How integral images are extended into 3D. 
-	The proposed algorithm of using Integral Volumes to speed up the process of polygonising an implicit object using the Marching Cubes algorithm
-	Implementation details that contribute to the efficiency and speed up of the algorithm
-	Results
\subsection{Background}\label{Vis_Background}
Much research has been done so far on optimising and improving the polygonisation of implicit surfaces. But most research is based on closed and manifold object. A polygon mesh is closed when it has no holes and it is manifold when it can be unfolded into a 2D continues surface. In order to guarantee consistent topology, an optimised approach with an enhanced look up table was proposed by Lewiner et al in 2003. \newline\newline
Further surface-tracking was discussed in both papers of (Rodrigues de Araujo and Pires Jorge, 2005) (Hartmann, 1998). Starting from a seed point, the surface is expanded according to the local curvature of the implicit object. Self-intersections and collisions are avoided using heuristic edge length. This method is considered to be faster and more efficient, in comparison with the Marching Cubes algorithm. Because, by tracking the surface, huge empty spaces are not searched and it is also possible to create smaller triangles on places with high gradient changes and bigger triangles on surfaces with low variance. Nevertheless, surface-tracking Algorithms cannot be applied in our case though, because the output of on my program is a non-manifold objects. The 3D Volume generated from FW LiDAR data is not consistent, since small footprint Leica FW systems cannot guarantee that the last return is from the ground. For that reason, it is possible that some trees may be separated from the ground. Surface-tracking algorithms converge once the object is closed. Therefore, there is a possibility that they may converge after polygonising a single tree if the seed point lies on a tree that is separated from the ground. \newline\newline
In 1992, Hansen and Hinker proposed parallelising the polygonisation process of BlobTree trees on Single Instruction, Multiple Data (SIMD) machines. BlobTree trees represent implicit objects as a combination of primitives and operations likes union and blends (Galbraith, MacMurchy, and Wyvill, 2004). While the depth of the tree increases, the time required to get the value that defines whether a point is inside or outside the object increases as well. On SIMD machines greater speed up is achieved at longer instruction due to the less communication cost. Therefore parallelising the process of BlobTree trees with long depth is beneficial, but in our case the value returned for a given point is calculated in constant time. Further, according to the C++ Coding Standards by Sutter and Alexandrescu, when optimisation is required is better to seek an algorithmic approach first because it is simpler to maintain and the possibility of being bug free is higher (Sutter and Alexandrescu, 2004). \newline\newline
OpenVDB library manages volumetric data with octrees. My program uses 1D arrays allowing constant time access of voxel values and by importing OpenVDB library, its speed was significantly decreased; while the number of voxels is increasing the time required to get the value of a voxel is also increasing. Further according to the documentation, the VolumeToMesh class “meshes any scalar grid that has a continuous isosurface”, while the surface of the FW LiDAR volumes is not continuous; there are triangles that represent leafs inside the trees and some of the trees may be disconnected from the ground because the last return do not always reach the earth  (OpenVDB 2.3.0). \newline\newline
In this report, it is introduced a new method of optimising the marching cubes algorithm. This method utilises Integral Volumes (an extension of Integral Images) to discard chunks of empty cubes during polygonisation. Its effectiveness stands at the ability of integral volumes to find the sum of any sub-volume into constant time and it is important because it works effectively non-manifold or non-closed objects. \newline\newline


\end{document}